package gracefulsoul.problems;

public class MinimizeMalwareSpreadII {

	// https://leetcode.com/problems/minimize-malware-spread-ii/submissions/960171015/
	public static void main(String[] args) {
		MinimizeMalwareSpreadII test = new MinimizeMalwareSpreadII();
		System.out.println(test.minMalwareSpread(new int[][] {
			{ 1, 1, 0 },
			{ 1, 1, 0 },
			{ 0, 0, 1 }
		}, new int[] { 0, 1 }));
		System.out.println(test.minMalwareSpread(new int[][] {
			{ 1, 1, 0 },
			{ 1, 1, 1 },
			{ 0, 1, 1 }
		}, new int[] { 0, 1 }));
		System.out.println(test.minMalwareSpread(new int[][] {
			{ 1, 1, 0, 0 },
			{ 1, 1, 1, 0 },
			{ 0, 1, 1, 1 },
			{ 0, 0, 1, 1 }
		}, new int[] { 0, 1 }));
	}

	public int minMalwareSpread(int[][] graph, int[] initial) {
		int length = graph.length;
		int result = initial[0];
		int max = 0;
		boolean[] infected = new boolean[length];
		for (int initialInfected : initial) {
			infected[initialInfected] = true;
		}
		int[] depth = new int[length];
		int[] low = new int[length];
		int[] count = new int[length];
		for (int initialInfected : initial) {
			if (depth[initialInfected] == 0) {
				this.dfs(graph, initialInfected, -1, 1, depth, low, infected, count);
			}
			if (count[initialInfected] > max || count[initialInfected] == max && initialInfected < result) {
				max = count[initialInfected];
				result = initialInfected;
			}
		}
		return result;
	}

	private int dfs(int[][] graph, int initialInfected, int parent, int time, int[] depth, int[] low, boolean[] infected, int[] count) {
		low[initialInfected] = depth[initialInfected] = time;
		boolean flag = infected[initialInfected];
		int size = 1;
		for (int i = 0; i < graph[initialInfected].length; i++) {
			if (graph[initialInfected][i] == 1) {
				if (depth[i] == 0) {
					int spreadCount = this.dfs(graph, i, initialInfected, time + 1, depth, low, infected, count);
					if (spreadCount == 0) {
						flag = true;
					} else {
						size += spreadCount;
					}
					if (low[i] >= depth[initialInfected]) {
						count[initialInfected] += spreadCount;
					}
					low[initialInfected] = Math.min(low[initialInfected], low[i]);
				} else if (i != parent) {
					low[initialInfected] = Math.min(low[initialInfected], depth[i]);
				}
			}
		}
		return flag ? 0 : size;
	}

}
